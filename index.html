<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doodle Art AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Permanent+Marker&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(243,244,246,1) 100%);
        }
        .container {
            max-width: 1200px;
        }
        .card {
            background-color: white;
            border-radius: 2rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transition: transform 0.3s ease;
        }
        .card:hover {
            transform: translateY(-5px);
        }
        .title-font {
            font-family: 'Permanent Marker', cursive;
            color: #dc2626; /* A slightly darker red */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .btn {
            @apply px-8 py-4 rounded-full font-bold transition-all duration-300;
        }
        .btn-primary {
            @apply bg-red-600 text-white hover:bg-red-700 border-2 border-red-800 hover:shadow-md;
        }
        .btn-secondary {
            @apply bg-green-600 text-white hover:bg-green-700 border-2 border-green-800 hover:shadow-md;
        }
        .btn-copy {
            @apply bg-transparent text-red-600 border-2 border-red-600 hover:bg-red-50 hover:text-red-700;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ef4444; /* Red spinner */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        canvas {
            border: 3px solid #e5e7eb;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            cursor: crosshair;
            background-color: white;
            touch-action: none;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="container mx-auto space-y-12">
        <header class="text-center mb-12">
            <h1 class="title-font text-5xl md:text-6xl font-bold mb-4">Doodle Art AI</h1>
            <p class="text-lg text-gray-600">Bring your imagination to life with AI-powered art generation.</p>
        </header>

        <!-- Section 1: Text-to-Image Generator -->
        <div class="card p-6 md:p-10 flex flex-col items-center">
            <h2 class="text-3xl font-semibold text-gray-800 mb-6 text-center">Generate from Text</h2>
            <div class="w-full max-w-2xl">
                <p class="text-gray-600 mb-4 text-center">Type a detailed description of what you want to create.</p>
                <div class="flex flex-col md:flex-row items-center gap-4">
                    <input type="text" id="promptInput" placeholder="A magical forest with glowing mushrooms and tiny fairies, watercolor style" class="flex-grow w-full md:w-auto p-4 rounded-full border border-gray-300 focus:outline-none focus:ring-2 focus:ring-red-600">
                    <button id="generateBtn" class="btn btn-primary w-full md:w-auto flex items-center justify-center gap-2">
                        Generate Images
                        <div id="textSpinner" class="hidden loading-spinner"></div>
                    </button>
                </div>
            </div>
            <div id="textResultContainer" class="mt-8 w-full max-w-4xl flex items-center justify-center min-h-[300px] text-center">
                <div id="textImageGrid" class="grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
                <p id="textPlaceholder" class="text-gray-400">Your generated images will appear here.</p>
            </div>
        </div>

        <!-- Section 2: Drawing Analyzer and Generator -->
        <div class="card p-6 md:p-10 flex flex-col items-center">
            <h2 class="text-3xl font-semibold text-gray-800 mb-6 text-center">Generate from Your Drawing</h2>
            <p class="text-gray-600 mb-4 text-center">Draw something on the canvas below, and the AI will analyze it and create new images.</p>
            
            <div class="w-full max-w-4xl flex flex-col lg:flex-row items-center lg:items-start gap-8">
                <!-- Drawing Canvas -->
                <div class="flex-1 w-full flex flex-col items-center gap-4">
                    <canvas id="drawingCanvas" width="400" height="400" class="rounded-xl shadow-inner"></canvas>
                    <button id="clearBtn" class="btn btn-secondary w-full max-w-[400px]">Clear Canvas</button>
                </div>
                
                <!-- Results and Buttons -->
                <div class="flex-1 w-full flex flex-col items-center">
                    <button id="analyzeBtn" class="btn btn-primary w-full md:w-2/3 lg:w-full flex items-center justify-center gap-2">
                        Analyze & Generate
                        <div id="drawSpinner" class="hidden loading-spinner"></div>
                    </button>
                    
                    <div class="mt-8 w-full">
                        <h3 class="font-semibold text-xl text-gray-700 mb-2">AI Description:</h3>
                        <div class="flex items-center gap-2 mb-2">
                            <p id="descriptionText" class="p-4 bg-gray-100 rounded-xl text-gray-600 italic flex-grow min-h-[50px]">Description will appear here after analysis...</p>
                            <button id="copyPromptBtn" class="btn btn-copy self-start px-4 py-2 text-sm hidden">Copy</button>
                        </div>
                    </div>
                    
                    <div class="mt-8 w-full">
                        <h3 class="font-semibold text-xl text-gray-700 mb-2">Generated Images:</h3>
                        <div id="drawResultContainer" class="flex items-center justify-center min-h-[300px] text-center">
                            <div id="drawImageGrid" class="grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
                            <p id="drawPlaceholder" class="text-gray-400">The generated images from your drawing will appear here.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Use a single variable to check if a request is in progress
        let isGenerating = false;
        
        // Configuration for exponential backoff
        const MAX_RETRIES = 3;
        const INITIAL_DELAY = 1000; // 1 second
        
        const textPromptInput = document.getElementById('promptInput');
        const generateBtn = document.getElementById('generateBtn');
        const textSpinner = document.getElementById('textSpinner');
        const textImageGrid = document.getElementById('textImageGrid');
        const textPlaceholder = document.getElementById('textPlaceholder');

        const drawingCanvas = document.getElementById('drawingCanvas');
        const ctx = drawingCanvas.getContext('2d');
        const clearBtn = document.getElementById('clearBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const drawSpinner = document.getElementById('drawSpinner');
        const descriptionText = document.getElementById('descriptionText');
        const drawImageGrid = document.getElementById('drawImageGrid');
        const drawPlaceholder = document.getElementById('drawPlaceholder');
        const copyPromptBtn = document.getElementById('copyPromptBtn');

        const API_KEY = ""; // This will be provided by the runtime
        const TEXT_TO_IMAGE_URL = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${API_KEY}`;
        const IMAGE_TO_TEXT_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
        const GENERATE_IMAGES_COUNT = 4; // Number of images to generate at once for text-to-image

        // --- Utility Function for Exponential Backoff ---
        async function fetchWithBackoff(url, options, retries = MAX_RETRIES, delay = INITIAL_DELAY) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    if (response.status === 429 && retries > 0) {
                        await new Promise(res => setTimeout(res, delay));
                        return fetchWithBackoff(url, options, retries - 1, delay * 2);
                    }
                    throw new Error(`API call failed with status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('Fetch error:', error);
                if (retries > 0) {
                    await new Promise(res => setTimeout(res, delay));
                    return fetchWithBackoff(url, options, retries - 1, delay * 2);
                }
                throw error;
            }
        }

        // --- Text-to-Image Logic ---
        generateBtn.addEventListener('click', async () => {
            if (isGenerating) return;

            const prompt = textPromptInput.value.trim();
            if (!prompt) {
                textPromptInput.placeholder = "Please enter a prompt!";
                return;
            }

            isGenerating = true;
            generateBtn.disabled = true;
            textSpinner.classList.remove('hidden');
            textPlaceholder.classList.add('hidden');
            textImageGrid.innerHTML = ''; // Clear previous images

            try {
                const payload = {
                    instances: { prompt: prompt },
                    parameters: { "sampleCount": GENERATE_IMAGES_COUNT }
                };

                const result = await fetchWithBackoff(TEXT_TO_IMAGE_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (result.predictions && result.predictions.length > 0) {
                    result.predictions.forEach(prediction => {
                        const imageUrl = `data:image/png;base64,${prediction.bytesBase64Encoded}`;
                        const img = document.createElement('img');
                        img.src = imageUrl;
                        img.className = "rounded-2xl max-w-full max-h-[300px] object-cover";
                        img.alt = "Generated Image";
                        textImageGrid.appendChild(img);
                    });
                } else {
                    textPlaceholder.innerText = "Could not generate images. Please try a different prompt.";
                    textPlaceholder.classList.remove('hidden');
                    console.error('API response structure is unexpected:', result);
                }
                
            } catch (error) {
                console.error('Failed to generate images:', error);
                textPlaceholder.innerText = "An error occurred. Please try again later.";
                textPlaceholder.classList.remove('hidden');
            } finally {
                isGenerating = false;
                generateBtn.disabled = false;
                textSpinner.classList.add('hidden');
            }
        });

        // --- Drawing Canvas Logic ---
        let isDrawing = false;
        
        function getPos(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            if (e.touches) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            } else {
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
        }

        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = '#000000';
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);

        drawingCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            ctx.beginPath();
            const pos = getPos(e);
            ctx.moveTo(pos.x, pos.y);
        });

        drawingCanvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                const pos = getPos(e);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            }
        });

        drawingCanvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        drawingCanvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        drawingCanvas.addEventListener('touchstart', (e) => {
            isDrawing = true;
            ctx.beginPath();
            const pos = getPos(e);
            ctx.moveTo(pos.x, pos.y);
            e.preventDefault();
        });

        drawingCanvas.addEventListener('touchmove', (e) => {
            if (isDrawing) {
                const pos = getPos(e);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            }
            e.preventDefault();
        });

        drawingCanvas.addEventListener('touchend', () => {
            isDrawing = false;
        });

        clearBtn.addEventListener('click', () => {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            descriptionText.innerText = "Description will appear here after analysis...";
            drawImageGrid.innerHTML = ''; // Clear images
            drawPlaceholder.classList.remove('hidden');
            copyPromptBtn.classList.add('hidden');
        });
        
        // --- Drawing Analyzer & Generator Logic ---
        analyzeBtn.addEventListener('click', async () => {
            if (isGenerating) return;

            isGenerating = true;
            analyzeBtn.disabled = true;
            drawSpinner.classList.remove('hidden');
            descriptionText.innerText = "Analyzing your drawing...";
            drawPlaceholder.classList.add('hidden');
            drawImageGrid.innerHTML = ''; // Clear previous images
            copyPromptBtn.classList.add('hidden');

            const imageDataUrl = drawingCanvas.toDataURL('image/png');
            const base64Data = imageDataUrl.split(',')[1];

            try {
                // Step 1: Analyze the drawing and get a text description.
                const analysisPayload = {
                    contents: [{
                        role: "user",
                        parts: [
                            { text: "Describe this drawing. The description will be used to generate a new image, so be detailed and creative." },
                            { inlineData: { mimeType: "image/png", data: base64Data } }
                        ]
                    }],
                };

                const analysisResult = await fetchWithBackoff(IMAGE_TO_TEXT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisPayload)
                });

                let description = "Could not generate a description.";
                const candidate = analysisResult?.candidates?.[0];
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    description = candidate.content.parts[0].text;
                }
                descriptionText.innerText = description;
                
                // Step 2: Generate an image from the description.
                descriptionText.innerText += "\n\nGenerating new image...";
                
                const generationPayload = {
                    instances: { prompt: description },
                    parameters: { "sampleCount": 1 }
                };

                const generationResult = await fetchWithBackoff(TEXT_TO_IMAGE_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(generationPayload)
                });
                
                if (generationResult.predictions && generationResult.predictions.length > 0) {
                    const imageUrl = `data:image/png;base64,${generationResult.predictions[0].bytesBase64Encoded}`;
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.className = "rounded-2xl max-w-full max-h-[300px] object-cover";
                    img.alt = "Generated Image";
                    drawImageGrid.appendChild(img);
                    descriptionText.innerText = description; // Final description
                    copyPromptBtn.classList.remove('hidden');
                } else {
                    drawPlaceholder.innerText = "Could not generate image from description. Please try again.";
                    drawPlaceholder.classList.remove('hidden');
                }

            } catch (error) {
                console.error('Failed to analyze and generate images:', error);
                descriptionText.innerText = "An error occurred during processing. Please try again.";
                drawPlaceholder.innerText = "An error occurred. Please try again.";
                drawPlaceholder.classList.remove('hidden');
            } finally {
                isGenerating = false;
                analyzeBtn.disabled = false;
                drawSpinner.classList.add('hidden');
            }
        });

        // --- Copy Prompt Button Logic ---
        copyPromptBtn.addEventListener('click', async () => {
            const textToCopy = descriptionText.innerText;
            const originalText = copyPromptBtn.innerText;
            try {
                // Use the modern clipboard API
                await navigator.clipboard.writeText(textToCopy);
                copyPromptBtn.innerText = "Copied!";
            } catch (err) {
                // Fallback for older browsers
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = textToCopy;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                document.execCommand('copy');
                document.body.removeChild(tempTextArea);
                copyPromptBtn.innerText = "Copied!";
            }
            setTimeout(() => {
                copyPromptBtn.innerText = originalText;
            }, 2000);
        });
    </script>

</body>
</html>

